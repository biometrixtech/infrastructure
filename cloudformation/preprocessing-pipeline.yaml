# A template that creates the processing pipeline for biometric data
#
# Copyright 2017 Melon Software Ltd (UK), all rights reserved
#
AWSTemplateFormatVersion: "2010-09-09"
Description: "Creates a pre-processing pipeline"

Parameters:

    Environment:
        Type: "String"
        Description: "The name of the Environment"

    BatchJobVersionDownloadandchunk:
        Type: "String"
        Description: "The version of the downloadandchunk batch job to run"
    BatchJobVersionSessionprocess2:
        Type: "String"
        Description: "The version of the sessionprocess2 batch job to run"
    BatchJobVersionNoop:
        Type: "String"
        Description: "The version of the `noop` batch job to run"
    BatchJobVersionScoring:
        Type: "String"
        Description: "The version of the `scoring` batch job to run"
    BatchJobVersionDatabaseupload:
        Type: "String"
        Description: "The version of the `databaseupload` batch job to run"

Metadata:
    "AWS::CloudFormation::Interface":
        ParameterGroups:
          - Label: { default: "Environment" }
            Parameters:
              - "Environment"
          - Label: { default: "Batch Jobs" }
            Parameters:
              - "BatchJobVersionDownloadandchunk"
              - "BatchJobVersionSessionprocess2"
              - "BatchJobVersionNoop"
              - "BatchJobVersionScoring"
              - "BatchJobVersionDatabaseupload"

        ParameterLabels:
            Environment: { default: "Environment" }
            BatchJobVersionDownloadandchunk: { default: "downloadandchunk" }
            BatchJobVersionSessionprocess2: { default: "sessionprocess2" }
            BatchJobVersionNoop: { default: "noop" }
            BatchJobVersionScoring: { default: "scoring" }
            BatchJobVersionDatabaseupload: { default: "databaseupload" }

Resources:

    ##########################################################################################################
    ##  IAM
    ##########################################################################################################

    LambdaExecutionRole:
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: "Allow"
                    Principal: { Service: [ "lambda.amazonaws.com" ] }
                    Action: "sts:AssumeRole"
            ManagedPolicyArns:
              - "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
            Policies:
              - PolicyName: "default"
                PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Action:
                          - "logs:CreateLogGroup"
                          - "logs:CreateLogStream"
                          - "logs:PutLogEvents"
                        Effect: "Allow"
                        Resource: "*"

                      - Action:
                          - "sns:Publish"
                          - "lambda:InvokeFunction"
                          - "states:StartExecution"
                          - "s3:ListBucket"
                        Effect: "Allow"
                        Resource: "*"

                      - Action:
                          - "ssm:DescribeParameters"
                          - "ssm:GetParameters"
                          - "kms:Decrypt"
                        Effect: "Allow"
                        Resource:
                          - "*" # TODO this should be segregated by environment somehow
            RoleName: { "Fn::Sub": "preprocessing-${Environment}-lambda-${AWS::Region}" }

    ##########################################################################################################
    ##  LAMBDA
    ##########################################################################################################

    LambdaTrigger:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, json, time

                    def handler(event, context):
                        print(event)
                        s3_bucket = event['Records'][0]['s3']['bucket']['name']
                        s3_key = event['Records'][0]['s3']['object']['key'].split('/')[-1]

                        combiner = '_'
                        if combiner in s3_key:
                            # A multipart upload
                            s3_basepath, part = s3_key.split(combiner)
                            if part == 'complete':
                                # Ready to combine
                                s3_basepath = s3_basepath
                                suffixes = [s.replace(s3_basepath + combiner, '') for s in list_s3_files(s3_bucket, s3_basepath)]

                            else:
                                # Not the final part
                                return

                        else:
                            # A complete file
                            s3_basepath = s3_key
                            combiner = ''
                            suffixes = []

                        execution_name = '{}-{}'.format(s3_key, int(time.time()))
                        sfn_client = boto3.client('stepfunctions')
                        res = sfn_client.start_execution(
                            stateMachineArn="arn:aws:states:us-west-2:887689817172:stateMachine:StateMachine-XEPGYPQQM6VJ",
                            name=execution_name,
                            input=json.dumps({
                                "Meta": {
                                    "ExecutionArn": "arn:aws:states:us-west-2:887689817172:execution:StateMachine-XEPGYPQQM6VJ:{}".format(execution_name),
                                    "ExecutionName": execution_name,
                                },
                                "SourceEvent": {
                                    "S3Bucket": s3_bucket,
                                    "S3BasePath": s3_basepath + combiner,
                                    "S3Suffixes": suffixes,
                                }
                            })
                        )

                        audit_packets(s3_bucket, s3_basepath, suffixes)


                    s3_client = boto3.client('s3')
                    def list_s3_files(bucket, prefix, marker=''):
                        objects_list = []
                        resp = s3_client.list_objects(Bucket=bucket, Prefix=prefix, Marker=marker)
                        objects_list.extend([x['Key'] for x in resp['Contents'] if x['Key'][-8:] != 'combined'])
                        while resp['IsTruncated']:
                            objects_list.extend(list_s3_files(bucket, prefix, objects_list[-1][0]))
                        return sorted(objects_list)


                    def audit_packets(bucket, prefix, packets):
                        expected_packets = ["{:04d}".format(i + 1) for i in range(len(packets) - 1)] + ["complete"]
                        if sorted(packets) != sorted(expected_packets):
                            try:
                                cloudwatch_client = boto3.client('cloudwatch')
                                cloudwatch_client.put_metric_data(
                                    Namespace='Preprocessing',
                                    MetricData=[
                                        {
                                            'MetricName': 'MissingPackets',
                                            'Dimensions': [
                                                {'Name': 'Environment', 'Value': os.environ['ENVIRONMENT']},
                                            ],
                                            'Timestamp': datetime.utcnow(),
                                            'Value': max(len(expected_packets) - len(packets), 1),
                                        },
                                    ]
                                )
                            except Exception as exception:
                                pass



            Handler: "index.handler"
            MemorySize: "256"
            Runtime: "python3.6"
            Timeout: "60"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-trigger" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-trigger" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }


    LambdaPrepareDownloadAndChunk:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ActivityArn": "${StepFunctionsActivity}",
                                "ExecutionArn": event['Meta']['ExecutionArn'],
                                "ExecutionName": event['Meta']['ExecutionName'],
                                "Environment": "${Environment}"
                            },
                            "Branches": [
                                {
                                    "Resource": {
                                        "BatchJobQueue": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute",
                                        "BatchJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionDownloadandchunk}",
                                        "BatchJob": "downloadandchunk",
                                        "Memory": 2048,
                                        "Vcpus": 2,
                                    },
                                    "InputPath": "$"
                                }
                            ],
                            "Input": event['SourceEvent']
                        }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-downloadandchunk" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-downloadandchunk" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaReadPostgres:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, json, os
                    lambda_client = boto3.client('lambda', region_name='us-west-2')
                    def query(query, parameters):
                        res = json.loads(lambda_client.invoke(
                            FunctionName='arn:aws:lambda:us-west-2:887689817172:function:preprocessing-dev-pipeline-querypostgres',
                            Payload=json.dumps({
                                "Queries": [{"Query": query, "Parameters": parameters}],
                                "Config": {"ENVIRONMENT": os.environ['ENVIRONMENT']}
                            }),
                        )['Payload'].read())
                        result, error = res['Results'][0], res['Errors'][0]
                        if error is not None:
                            raise Exception(error)
                        else:
                            return result[0] if len(result) else {}

                    def handler(event, context):
                        query_results = query(
                            """SELECT
                              session_events.id AS session_event_id,
                              session_events.training_session_log_id,
                              session_events.hip_n_transform,
                              session_events.training_group_ids,
                              session_events.user_id,
                              users.weight,
                              training_groups.team_id,
                              session_events.session_type
                            FROM session_events
                            LEFT JOIN users ON session_events.user_id=users.id
                            LEFT JOIN training_groups ON training_groups.id = session_events.training_group_ids[1]
                            WHERE session_events.sensor_data_filename = %s""",
                            [event['SourceEvent']['S3BasePath'].rstrip('_')]
                        )
                        ret = {
                            "SessionEventId": query_results.get('session_event_id', None),
                            "TrainingSessionLogId": query_results.get('training_session_log_id', None),
                            "HipNTransform": query_results.get('hip_n_transform', None),
                            "TrainingGroupId": query_results.get('training_group_ids', None),
                            "UserId": query_results.get('user_id', None),
                            "UserWeight": query_results.get('weight', None),
                            "TeamId": query_results.get('team_id', None),
                            "SessionType": query_results.get('session_type', None),
                        }
                        query_result = query(
                            "SELECT * FROM fn_get_sensor_data_filename_hist((%s))",
                            [ret['UserId']]
                        )
                        ret["HistoricalFiles"] = query_result
                        return ret

            Environment:
                Variables:
                    ENVIRONMENT: { Ref: "Environment" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-readpostgres" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-readpostgres" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareSessionProcess2:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ActivityArn": "${StepFunctionsActivity}",
                                "ExecutionArn": event['Meta']['ExecutionArn'],
                                "ExecutionName": event['Meta']['ExecutionName'],
                                "Environment": "${Environment}",
                                "NoopJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionNoop}"
                            },
                            "Branches": [
                                {
                                    "Resource": {
                                        "BatchJobQueue": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute",
                                        "BatchJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionSessionprocess2}",
                                        "BatchJob": "sessionprocess2",
                                        "Memory": 1024,
                                        "Vcpus": 2,
                                    },
                                    "InputPath": "$[{}]".format(i)
                                }
                                for i in range(len(event['DownloadAndChunk'][1]['Output']['Filenames']))
                            ],
                            "Input": [
                                {**event["ReadDatabase"], **{"Filename": f}}
                                for f in event['DownloadAndChunk'][1]['Output']['Filenames']
                            ]
                        }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-sessionprocess2" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-sessionprocess2" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareScoring:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ActivityArn": "${StepFunctionsActivity}",
                                "ExecutionArn": event['Meta']['ExecutionArn'],
                                "ExecutionName": event['Meta']['ExecutionName'],
                                "Environment": "${Environment}",
                                "NoopJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionNoop}"
                            },
                            "Branches": [
                                {
                                    "Resource": {
                                        "BatchJobQueue": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute",
                                        "BatchJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionScoring}",
                                        "BatchJob": "scoring",
                                        "Memory": 4096,
                                        "Vcpus": 4,
                                    },
                                    "InputPath": "$"
                                }
                            ],
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Filenames": event['DownloadAndChunk'][1]['Output']['Filenames']}
                            }
                        }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-scoring" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-scoring" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaWritePostgres:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, json, os
                    def handler(event, context):
                        lambda_client = boto3.client('lambda', region_name='us-west-2')
                        res = json.loads(lambda_client.invoke(
                            FunctionName='arn:aws:lambda:us-west-2:887689817172:function:preprocessing-dev-pipeline-querypostgres',
                            Payload=json.dumps({
                                "Queries": [{
                                    "Query": "UPDATE session_events SET session_success=True, updated_at = now() WHERE id = %s",
                                    "Parameters": [event['ReadDatabase']['SessionEventId']]
                                }],
                                "Config": {"ENVIRONMENT": os.environ['ENVIRONMENT']}
                            }),
                        )['Payload'].read())
                        if res['Errors'][0] is not None:
                            raise Exception(res['Errors'][0])
                        return {}

            Environment:
                Variables:
                    ENVIRONMENT: { Ref: "Environment" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-writepostgres" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-writepostgres" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareWriteMongo:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ActivityArn": "${StepFunctionsActivity}",
                                "ExecutionArn": event['Meta']['ExecutionArn'],
                                "ExecutionName": event['Meta']['ExecutionName'],
                                "Environment": "${Environment}",
                                "NoopJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionNoop}"
                            },
                            "Branches": [
                                {
                                    "Resource": {
                                        "BatchJobQueue": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute",
                                        "BatchJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionDatabaseupload}",
                                        "BatchJob": "writemongo",
                                        "Memory": 2048,
                                        "Vcpus": 2,
                                    },
                                    "InputPath": "$[{}]".format(i)
                                }
                                for i in range(len(event['Scoring'][1]['Output']['Filenames']))
                            ],
                            "Input": [
                                {**event["ReadDatabase"], **{"Filename": f}}
                                for f in event['Scoring'][1]['Output']['Filenames']
                            ]
                        }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-writemongo" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-writemongo" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaNotifySuccess:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        import boto3, os
                        sns_client = boto3.client('sns')
                        response = sns_client.publish(
                            TopicArn=os.environ['SNS_TOPIC'],
                            Message=event['ReadDatabase']['SessionEventId'],
                        )
            Environment:
                Variables:
                    SNS_TOPIC: { Ref: "SnsSuccessTopic" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-notifysuccess" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-notifysuccess" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareCleanup:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ActivityArn": "${StepFunctionsActivity}",
                                "ExecutionArn": event['Meta']['ExecutionArn'],
                                "ExecutionName": event['Meta']['ExecutionName'],
                                "Environment": "${Environment}",
                                "NoopJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionNoop}"
                            },
                            "Branches": [
                                {
                                    "Resource": {
                                        "BatchJobQueue": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute",
                                        "BatchJobDefinition": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/preprocessing-batchjob${BatchJobVersionScoring}",
                                        "BatchJob": "cleanup",
                                        "Memory": 256,
                                        "Vcpus": 2,
                                    },
                                    "InputPath": "$"
                                }
                            ],
                            "Input": {"Filename": event['SourceEvent']['S3BasePath']}
                        }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-cleanup" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-cleanup" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    ##########################################################################################################
    ##  LAMBDA
    ##########################################################################################################

    SnsSuccessTopic:
        Type: "AWS::SNS::Topic"
        Properties:
            DisplayName: "Biometrix preprocessing success notification"
            TopicName: { "Fn::Sub": "preprocessing-${Environment}-success" }

    ##########################################################################################################
    ##  STEP FUNCTIONS
    ##########################################################################################################

    StepFunctionsActivity:
        Type: "AWS::StepFunctions::Activity"
        Properties:
            Name: { "Fn::Sub": "preprocessing-${Environment}" }

    StateMachine:
        Type: "AWS::StepFunctions::StateMachine"
        Properties:
            DefinitionString: !Sub |
                {
                    "StartAt": "BuildDownloadAndChunkContext",
                    "States": {
                        "BuildDownloadAndChunkContext": {
                            "Type": "Task",
                            "Resource": "${LambdaPrepareDownloadAndChunk.Arn}",
                            "ResultPath": "$.DownloadAndChunk",
                            "Next": "DownloadAndChunk"
                        },
                        "DownloadAndChunk": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "ScheduleDownloadAndChunk",
                                    "States": {
                                        "ScheduleDownloadAndChunk": {
                                            "Type": "Task",
                                            "InputPath": "$.DownloadAndChunk",
                                            "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:preprocessing-sfn-batch-schedule",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "RespondDownloadAndChunk",
                                    "States": {
                                        "RespondDownloadAndChunk": {
                                            "Type": "Task",
                                            "InputPath": "$.DownloadAndChunk",
                                            "Resource": "${StepFunctionsActivity}",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": "$.DownloadAndChunk",
                            "Next": "ReadDatabase"
                        },
                        "ReadDatabase": {
                            "Type": "Task",
                            "Resource": "${LambdaReadPostgres.Arn}",
                            "ResultPath": "$.ReadDatabase",
                            "Next": "BuildSessionProcess2Context"
                        },
                        "BuildSessionProcess2Context": {
                            "Type": "Task",
                            "Resource": "${LambdaPrepareSessionProcess2.Arn}",
                            "ResultPath": "$.SessionProcess2",
                            "Next": "SessionProcess2"
                        },
                        "SessionProcess2": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "ScheduleSessionProcess2",
                                    "States": {
                                        "ScheduleSessionProcess2": {
                                            "Type": "Task",
                                            "InputPath": "$.SessionProcess2",
                                            "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:preprocessing-sfn-batch-schedule",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "RespondSessionProcess2",
                                    "States": {
                                        "RespondSessionProcess2": {
                                            "Type": "Task",
                                            "InputPath": "$.SessionProcess2",
                                            "Resource": "${StepFunctionsActivity}",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": "$.SessionProcess2",
                            "Next": "BuildScoringContext"
                        },
                        "BuildScoringContext": {
                            "Type": "Task",
                            "Resource": "${LambdaPrepareScoring.Arn}",
                            "ResultPath": "$.Scoring",
                            "Next": "Scoring"
                        },
                        "Scoring": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "ScheduleScoring",
                                    "States": {
                                        "ScheduleScoring": {
                                            "Type": "Task",
                                            "InputPath": "$.Scoring",
                                            "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:preprocessing-sfn-batch-schedule",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "RespondScoring",
                                    "States": {
                                        "RespondScoring": {
                                            "Type": "Task",
                                            "InputPath": "$.Scoring",
                                            "Resource": "${StepFunctionsActivity}",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": "$.Scoring",
                            "Next": "Upload"
                        },
                        "Upload": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "WritePostgres",
                                    "States": {
                                        "WritePostgres": {
                                            "Type": "Task",
                                            "Resource": "${LambdaWritePostgres.Arn}",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildWriteMongoContext",
                                    "States": {
                                        "BuildWriteMongoContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareWriteMongo.Arn}",
                                            "ResultPath": "$.WriteMongo",
                                            "Next": "WriteMongo"
                                        },
                                        "WriteMongo": {
                                            "Type": "Parallel",
                                            "Branches": [
                                                {
                                                    "StartAt": "ScheduleWriteMongo",
                                                    "States": {
                                                        "ScheduleWriteMongo": {
                                                            "Type": "Task",
                                                            "InputPath": "$.WriteMongo",
                                                            "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:preprocessing-sfn-batch-schedule",
                                                            "End": true
                                                        }
                                                    }
                                                },
                                                {
                                                    "StartAt": "RespondWriteMongo",
                                                    "States": {
                                                        "RespondWriteMongo": {
                                                            "Type": "Task",
                                                            "InputPath": "$.WriteMongo",
                                                            "Resource": "${StepFunctionsActivity}",
                                                            "End": true
                                                        }
                                                    }
                                                }
                                            ],
                                            "ResultPath": "$.WriteMongo",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": null,
                            "Next": "Post"
                        },
                        "Post": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "Notify",
                                    "States": {
                                        "Notify": {
                                            "Type": "Task",
                                            "Resource": "${LambdaNotifySuccess.Arn}",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildCleanupContext",
                                    "States": {
                                        "BuildCleanupContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareCleanup.Arn}",
                                            "ResultPath": "$.Cleanup",
                                            "Next": "Cleanup"
                                        },
                                        "Cleanup": {
                                            "Type": "Parallel",
                                            "Branches": [
                                                {
                                                    "StartAt": "ScheduleCleanup",
                                                    "States": {
                                                        "ScheduleCleanup": {
                                                            "Type": "Task",
                                                            "InputPath": "$.Cleanup",
                                                            "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:preprocessing-sfn-batch-schedule",
                                                            "End": true
                                                        }
                                                    }
                                                },
                                                {
                                                    "StartAt": "RespondCleanup",
                                                    "States": {
                                                        "RespondCleanup": {
                                                            "Type": "Task",
                                                            "InputPath": "$.Cleanup",
                                                            "Resource": "${StepFunctionsActivity}",
                                                            "End": true
                                                        }
                                                    }
                                                }
                                            ],
                                            "ResultPath": "$.Cleanup",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": "$.Cleanup",
                            "End": true
                        }
                    }
                }

            RoleArn: { "Fn::ImportValue" : "StepFunctionsServiceRole" }
Outputs:
    ActivityArn:
        Description: "The ARN of the Batch Activity"
        Value: { Ref: "StepFunctionsActivity" }
    TriggerLambdaArn:
        Description: "The ARN of the trigger lambda"
        Value: { "Fn::GetAtt": [ "LambdaTrigger", "Arn" ] }
